#!/usr/bin/env bash
set -euo pipefail

ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Configure supported types here.
# - VALUE_TYPES: Swift value types passed by value.
# - OBJECT_TYPES: object/CFType types. Use Name:SwiftType to customize file/function name.
#   Keep Object:AnyObject last so it acts as a catch-all for all class types.
#
# Example: to support CGContext, add "CGContext" before Object:AnyObject.
VALUE_TYPES=(Int CGSize CGRect)
OBJECT_TYPES=(Object:AnyObject)

ENTRY_NAME=""
ENTRY_TYPE=""

parse_entry() {
  local entry="$1"
  local name="${entry%%:*}"
  local swift_type="${entry#*:}"
  if [[ "$entry" == "$name" ]]; then
    swift_type="$name"
  fi
  ENTRY_NAME="$name"
  ENTRY_TYPE="$swift_type"
}

write_file() {
  local name="$1"
  local swift_type="$2"
  local cast_body="$3"
  local output_path="$ROOT/InstanceMethodInterceptor+Single${name}Void.swift"

  cat > "$output_path" <<EOF
//
//  InstanceMethodInterceptor+Single${name}Void.swift
//  ChouTi
//
//  Copyright Â© 2020 Honghao Zhang.
//
//  MIT License
//
//  Copyright (c) 2020 Honghao Zhang (github.com/honghaoz)
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to
//  deal in the Software without restriction, including without limitation the
//  rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
//  sell copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
//  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
//  IN THE SOFTWARE.
//

// Generated by generate_single_arg_void.sh. Do not edit directly.

import Foundation
import ObjectiveC

extension InstanceMethodInterceptor {

  private typealias VoidMethodWith${name}IMP = @convention(c) (AnyObject, Selector, ${swift_type}) -> Void

  static func addSubclassOverrideWith${name}IfNeeded(
    subclass: AnyClass,
    originalClass: AnyClass,
    selector: Selector
  ) {
    let key = "\(NSStringFromClass(subclass))|\(NSStringFromSelector(selector))"

    subclassSelectorOverridesLock.lock()
    if subclassSelectorOverrides.contains(key) {
      subclassSelectorOverridesLock.unlock()
      return
    }
    subclassSelectorOverrides.insert(key)
    subclassSelectorOverridesLock.unlock()

    guard let originalMethod = class_getInstanceMethod(originalClass, selector) else {
      ChouTi.assertFailure("Failed to get original method for subclass override") // impossible
      return
    }

    let originalImplementation = unsafeBitCast(
      class_getMethodImplementation(originalClass, selector),
      to: VoidMethodWith${name}IMP.self
    )

    let newImplementation: @convention(block) (AnyObject, ${swift_type}) -> Void = { object, arg in
      let callOriginal: (Any) -> Void = { value in
${cast_body}
      }
      invokeHooksWithAnyArg(on: object, selector: selector, arg: arg, callOriginal: callOriginal)
    }

    let methodTypeEncoding = method_getTypeEncoding(originalMethod)
    let newIMP = imp_implementationWithBlock(newImplementation)
    class_addMethod(subclass, selector, newIMP, methodTypeEncoding)
    subclassMethodIMPs.append(newIMP)
  }

  /// Swizzles the original class method (single argument) when KVO has already swizzled the instance.
  static func swizzleOriginalMethodWith${name}(
    originalClass: AnyClass,
    selector: Selector
  ) {
    let key = methodKey(originalClass: originalClass, selector: selector)

    swizzledMethodsLock.lock()
    if swizzledMethods.contains(key) {
      swizzledMethodsLock.unlock()
      return
    }
    swizzledMethods.insert(key)
    swizzledMethodsLock.unlock()

    guard let originalMethod = class_getInstanceMethod(originalClass, selector) else {
      ChouTi.assertFailure("Failed to get method for original class swizzling") // impossible
      return
    }

    let originalIMP = method_getImplementation(originalMethod)
    let originalImplementation = unsafeBitCast(originalIMP, to: VoidMethodWith${name}IMP.self)

    let newImplementation: @convention(block) (AnyObject, ${swift_type}) -> Void = { object, arg in
      let callOriginal: (Any) -> Void = { value in
${cast_body}
      }
      invokeHooksWithAnyArg(on: object, selector: selector, arg: arg, callOriginal: callOriginal)
    }

    let newIMP = imp_implementationWithBlock(newImplementation)
    method_setImplementation(originalMethod, newIMP)

    swizzledMethodOriginalIMPsLock.lock()
    swizzledMethodOriginalIMPs[key] = originalIMP
    swizzledMethodOriginalIMPsLock.unlock()

    swizzledMethodIMPsLock.lock()
    swizzledMethodIMPs[key] = newIMP
    swizzledMethodIMPsLock.unlock()
  }
}
EOF
}

guard_cast_body() {
  local type="$1"
  cat <<EOF
        guard let typedValue = value as? ${type} else {
          ChouTi.assertFailure("intercept arg type mismatch", metadata: [
            "selector": NSStringFromSelector(selector),
            "expected": String(describing: ${type}.self),
            "actual": String(describing: type(of: value)),
          ])
          return
        }
        originalImplementation(object, selector, typedValue)
EOF
}

object_cast_body() {
  local type="$1"
  cat <<EOF
        originalImplementation(object, selector, value as ${type})
EOF
}

generate_dispatch_block() {
  for entry in "${VALUE_TYPES[@]}"; do
    parse_entry "$entry"
    local name="$ENTRY_NAME"
    local swift_type="$ENTRY_TYPE"
    cat <<EOF
    if Arg.self == ${swift_type}.self {
      return interceptSingleArg(
        object,
        selector: selector,
        block: erasedBlock,
        addSubclassOverride: addSubclassOverrideWith${name}IfNeeded,
        swizzleOriginalMethod: swizzleOriginalMethodWith${name}
      )
    }
EOF
  done

  for entry in "${OBJECT_TYPES[@]}"; do
    parse_entry "$entry"
    local name="$ENTRY_NAME"
    local swift_type="$ENTRY_TYPE"
    if [[ "$swift_type" == "AnyObject" ]]; then
      local condition="Arg.self is AnyObject.Type"
    else
      local condition="Arg.self == ${swift_type}.self"
    fi

    cat <<EOF
    if ${condition} {
      return interceptSingleArg(
        object,
        selector: selector,
        block: erasedBlock,
        addSubclassOverride: addSubclassOverrideWith${name}IfNeeded,
        swizzleOriginalMethod: swizzleOriginalMethodWith${name}
      )
    }
EOF
  done
}

update_dispatch_block() {
  local shared_file="$ROOT/InstanceMethodInterceptor+SingleArgVoid.swift"
  local block_file
  block_file="$(mktemp)"

  generate_dispatch_block > "$block_file"

  awk -v block_file="$block_file" '
    /BEGIN GENERATED SINGLE ARG DISPATCH/ {
      print
      while ((getline line < block_file) > 0) print line
      close(block_file)
      skip=1
      next
    }
    /END GENERATED SINGLE ARG DISPATCH/ {
      skip=0
      print
      next
    }
    !skip { print }
  ' "$shared_file" > "$shared_file.tmp" && mv "$shared_file.tmp" "$shared_file"

  rm -f "$block_file"
}

for entry in "${VALUE_TYPES[@]}"; do
  parse_entry "$entry"
  cast_body="$(guard_cast_body "$ENTRY_TYPE")"
  write_file "$ENTRY_NAME" "$ENTRY_TYPE" "$cast_body"
done

for entry in "${OBJECT_TYPES[@]}"; do
  parse_entry "$entry"
  cast_body="$(object_cast_body "$ENTRY_TYPE")"
  write_file "$ENTRY_NAME" "$ENTRY_TYPE" "$cast_body"
done

update_dispatch_block
